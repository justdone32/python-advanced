# 其它

### 为什么有了列表还需要元祖
两者的性质不同: 元祖中的元素不可变，列表可变。元祖的不可变性提供了某种完整性，这样你可以确保元祖在程序中不会被另一个引用改变，而列表就没法保证了。

元祖可以用在列表无法使用的情况中，例如，集合。因为集合中的元素是不可变的，当添加列表到集合中时会报错，而添加元素却不会报错。
    

### 引用vs拷贝
+ 引用
    赋值操作产生对象的引用。
    
    例如: a = "abc"，a就是对于字符串对象"abc"的引用。
    
+ 浅拷贝
    + 浅拷贝是对于一个对象的顶层拷贝。
    
    + 如何浅拷贝
        + 分片表达式可以赋值一个序列
            
            a = "abc"
            
            b = a[:]
            
        + 字典的copy方法可以拷贝一个字典
            
            d = dict(name="zhangsan", age=27")
            
            co = d.copy()
        
        + 有些内置函数可以生成拷贝(list)
        
            a = list(range(10))
            
            b = list(a)
        
        + copy模块中的copy函数
        
            import copy
            
            a = (1,2,3)
            
            b = copy.copy(a)
        
+ 深拷贝
    + 深拷贝是对于一个对象所有层次的拷贝(递归)。
    
    + 如何深拷贝
    
        copy模块中的deepcopy函数。
        
        import copy
        
        a = ["name", [1,2,3], "age"]
        
        co = copy.deepcopy(a)

### 循环导入
#### 为什么会出现循环导入

![循环导入错误](../media/importerr1.png)

再看一个例子


a.py
```python
from b import b 

print '---------this is module a.py----------'
def a():
    print "hello, a"   
    b() 

a()
```
b.py
```python
from a import a

print '----------this is module b.py----------'
def b():
    print "hello, b"

def c():
    a() 
c()
```
运行python a.py

![循环导入错误](../media/importerr.png)

#### 怎样避免循环导入

1. 程序设计上分层，降低耦合
2. 导入语句放在后面需要导入时再导入
3. 放在函数体内导入


### 共享引用和相等

在Python中先创建一个对象，然后再将变量指向所创建的对象。
对于每个对象，都有一个头部信息，在信息中就标记了这个对象的类型信息。每当一个变量名被赋予了一个新的对象，之前那个对象占用的空间就回被回收（如果此时这个对象没有被别的变量名或者对象所引用的话）。另外，在python中，每个对象都保有一个计数器，计数器中记录了这个对象被引用的次数，当这个计数器被置为0时，对象所占用的内存空间就会被释放，即当做垃圾回收。
共享引用：
在python中，变量总是一个指向对象的指针，而不是可以改变的内存区域标签。给一个变量赋予一个新的值，不是替换了原始的对象，而是让这个变量去引用一个新的对象，实际效果就是对变量重新赋值，这仅仅会影响到那个被重新赋值的变量。
另外，在这里说一下 “ == ”和“ is ”这个操作符
==，和C语言中的作用是一样的，测试两个被引用的对象的值是否一致；
is，检查两个对象的同一性，判断两个对象名是否指向同一地址空间，如果是则返回True
创建两个列表对象，即使它们的值相同，也是来源于不同的空间。因此is的比较结果为假.
在内存中，小的整数和字符串被缓存复用了，所以is才告诉我们小整数a和b是引用了相同的对象。

### 语句执行时间

+ 测试语句运行时间
```python
python -mtimeit -s 'from decimal import Decimal' '3.14+5.67'
python -mtimeit -s 'from decimal import Decimal' 'Decimal("3.14")+Decimal("5.67")'
```
![测试](../media/timeittest.png)

+ 测试函数运行时间

```python
import time
 
def time_me(fn):
    def _wrapper(*args, **kwargs):
        start = time.clock()
        fn(*args, **kwargs)
        print("%s cost %s second"%(fn.__name__, time.clock() - start))
    return _wrapper
 
@time_me
def test(x, y):
    time.sleep(0.1)
 
@time_me
def test2(x):
    time.sleep(0.2)
 
test(1, 2)
test2(2)
```

+ 测试文件运行时间

```shell
$ time -p python testfile.py

Total time running : 1.3931210041 seconds
real 1.49    表示的是执行脚本的总时间
user 1.40    表示的是执行脚本消耗的CPU时间。
sys 0.08     表示的是执行内核函数消耗的时间
```


## 协程

网络编程目前有四种方式：

+ 多进程
+ 多线程
+ 异步(多路I/O复用)
+ 协程


协程，又称微线程，纤程。英文名Coroutine。

在执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。
用于网络编程中，由于网络I/O阻塞，阻塞纤程让出CPU，让别的就绪纤程工作。


### 先来理解协程

```python
import time

def consumer():
    r = ''
    while True:
        n = yield r
        if not n:
            return
        print('[CONSUMER] Consuming %s...' % n)
        time.sleep(1)
        r = '200 OK'

def produce(c):
    c.next()
    n = 0
    while n < 5:
        n = n + 1
        print('[PRODUCER] Producing %s...' % n)
        r = c.send(n)
        print('[PRODUCER] Consumer return: %s' % r)
    c.close()

if __name__=='__main__':
    c = consumer()
    produce(c)
```

### Gevent协程解决方案

gevent是基于协程的Python网络库。
特点： 基于libev的快速事件循环(Linux上epoll，FreeBSD上kqueue）。
基于greenlet的轻量级执行单元。 

Gevent提供了看上去非常像传统的基于线程模型编程的接口，但是在隐藏在下面做的是异步I/O。

安装

    pip install gevent

上面例子使gevent.socket进行socket操作。如果使用标准socket模块将有3倍耗时。

monkey patching用兼容副本替换标准socket模块的函数和类。


```python
from gevent import monkey; monkey.patch_socket()
import gevent

def f(n):
    for i in range(n):
        print gevent.getcurrent(), i

g1 = gevent.spawn(f, 5)
g2 = gevent.spawn(f, 5)
g3 = gevent.spawn(f, 5)
g1.join()
g2.join()
g3.join()

```

增加睡眠语句，观察切换

```python
from gevent import monkey; monkey.patch_socket()
import gevent

def f(n):
    for i in range(n):
        print gevent.getcurrent(), i
        gevent.sleep(0)

g1 = gevent.spawn(f, 5)
g2 = gevent.spawn(f, 5)
g3 = gevent.spawn(f, 5)
g1.join()
g2.join()
g3.join()

```
然后在操作系统的进程管理器中看，线程数只有1个。

当然，实际代码里，我们不会用gevent.sleep()去切换协程，
而是在执行到IO操作时，gevent自动切换

```python
from gevent import monkey; monkey.patch_all()
import gevent
import urllib2

def f(url):
    print('GET: %s' % url)
    resp = urllib2.urlopen(url)
    data = resp.read()
    print('%d bytes received from %s.' % (len(data), url))

gevent.joinall([
        gevent.spawn(f, 'https://www.yahoo.com/'),
        gevent.spawn(f, 'https://www.python.org/'),
        gevent.spawn(f, 'https://github.com/'),
])
```